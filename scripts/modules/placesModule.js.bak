/**
 * Handles searching and importing restaurants from Google Places API
 * Provides modal search functionality similar to the Michelin module
 * Dependencies: dataStorage, apiHandler, window.uiUtils
 */

// Only declare the class if it doesn't already exist
if (typeof window.PlacesModule === 'undefined') {
    /**
     * Module for searching and importing restaurants from Google Places API
     */
    window.PlacesModule = class PlacesModule {
        constructor() {
            // Module properties
            this.apiEndpoint = 'https://maps.googleapis.com/maps/api/place';
            this.apiLoaded = false;
            this.placesService = null;
            this.autocompleteWidget = null;
            this.modalAutocompleteWidget = null;
            this.selectedPlace = null;
            this.searchResults = [];
            this.apiKey = '';
            this.isLoading = false;
            this.modalPlacesInitialized = false;
            this.currentLatitude = null;
            this.currentLongitude = null;
            this.dropdownObserver = null;
            this.repositionTimer = null;
        
        // Default to true, but check localStorage for user preference
        this.filterFoodPlacesOnly = localStorage.getItem('places_filter_food_only') !== 'false';
        
        // Debug mode
        this.debugEnabled = localStorage.getItem('places_debug_enabled') === 'true';
        
        // Initialize module
        this.initializeUI();
    }
    
    /**
     * Log debug messages when debug mode is enabled
     * @param {string} message - The message to log
     * @param {...any} args - Additional arguments to log
     */
    debugLog(message, ...args) {
        if (this.debugEnabled && window.console && typeof window.console.log === 'function') {
            console.log(`[Places] ${message}`, ...args);
        }
    }
    
    /**
     * Initialize UI elements and event handlers
     */
    initializeUI() {
        this.debugLog('Initializing Places module UI');
        
        // Create the search modal if it doesn't exist
        this.createModalIfNeeded();
        
        // Create menu button if needed
        this.createMenuButtonIfNeeded();
        
        // Set up event listeners
        this.setupEventListeners();
        
        // Attempt to load the API key from localStorage
        this.loadApiKey();
        
        this.debugLog('Places module initialized');
    }
    
    /**
     * Create the search modal if it doesn't exist
     */
    createModalIfNeeded() {
        if (!document.getElementById('places-search-modal')) {
            const modalHTML = `
                <div id="places-search-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-start justify-center z-50 hidden overflow-y-auto pt-4 pb-4">
                    <div class="bg-white rounded-lg shadow-xl border border-gray-100 w-full max-w-2xl mx-4 my-auto flex flex-col max-h-[90vh]">
                        <!-- Sticky header -->
                        <div class="sticky top-0 bg-white px-4 py-3 border-b border-gray-200 flex justify-between items-center z-10 rounded-t-lg">
                            <h2 class="text-lg md:text-xl font-bold flex items-center">
                                <span class="material-icons mr-2 text-blue-600">place</span>
                                Google Places Restaurants
                            </h2>
                            <button id="close-places-search-modal" class="text-gray-500 hover:text-gray-800 text-xl md:text-2xl p-1">&times;</button>
                        </div>

                        <div class="overflow-y-auto flex-grow px-4 pb-4">
                            <!-- API Key section -->
                            <div id="modal-places-api-key-section" class="my-4">
                                <p class="text-sm mb-2">Enter your Google Places API key:</p>
                                <div class="flex">
                                    <input type="password" id="modal-places-api-key" class="border rounded px-3 py-2 flex-grow mr-2" placeholder="Google Places API Key">
                                    <button id="modal-save-places-api-key" class="bg-blue-600 text-white px-3 py-2 rounded flex items-center text-sm">
                                        <span class="material-icons mr-1 text-sm">save</span>
                                        Save
                                    </button>
                                </div>
                                <p class="text-xs text-gray-500 mt-1">Required to use the Places API. Your API key is stored locally.</p>
                            </div>
                            
                            <!-- Search container (initially hidden) -->
                            <div id="modal-places-search-container" class="hidden">
                                <!-- Collapsible filters section -->
                                <div class="mb-4 mt-3">
                                    <button id="toggle-filters-btn" class="w-full py-2 px-3 bg-gray-100 rounded-md text-left flex justify-between items-center md:hidden">
                                        <span class="font-medium">Search Filters</span>
                                        <span class="material-icons">expand_more</span>
                                    </button>
                                    
                                    <div class="mt-3 space-y-3 md:space-y-0 md:grid md:grid-cols-2 md:gap-4 collapse-on-mobile">
                                        <div>
                                            <label for="modal-places-input" class="block text-sm font-medium text-gray-700 mb-1">Search for restaurants:</label>
                                            <div id="modal-places-autocomplete-container" class="relative">
                                                <!-- The Places Autocomplete widget will be placed here -->
                                            </div>
                                        </div>
                                        
                                        <div>
                                            <div class="flex flex-col space-y-2">
                                                <label class="flex items-center space-x-2 cursor-pointer py-2 px-1">
                                                    <input type="checkbox" id="modal-filter-food-places" class="form-checkbox" checked>
                                                    <span>Food places only</span>
                                                </label>
                                                
                                                <label class="flex items-center space-x-2 cursor-pointer py-2 px-1">
                                                    <input type="checkbox" id="search-places-location" class="form-checkbox">
                                                    <span>Near My Location</span>
                                                </label>
                                                
                                                <div>
                                                    <label for="search-places-radius" class="block text-sm font-medium text-gray-700">Radius (km):</label>
                                                    <select id="search-places-radius" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                                                        <option value="1">1 km</option>
                                                        <option value="2">2 km</option>
                                                        <option value="5" selected>5 km</option>
                                                        <option value="10">10 km</option>
                                                        <option value="20">20 km</option>
                                                        <option value="50">50 km</option>
                                                    </select>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Action buttons -->
                                <div class="flex flex-wrap gap-2 mb-4">
                                    <button id="places-search-btn" class="bg-blue-600 text-white px-3 py-2 rounded flex items-center text-sm">
                                        <span class="material-icons mr-1 text-sm">search</span>
                                        Search
                                    </button>
                                    <button id="places-search-map-btn" class="bg-blue-600 text-white px-3 py-2 rounded flex items-center text-sm">
                                        <span class="material-icons mr-1 text-sm">map</span>
                                        Map View
                                    </button>
                                    <button id="places-reset-btn" class="bg-gray-400 text-white px-3 py-2 rounded flex items-center text-sm">
                                        <span class="material-icons mr-1 text-sm">refresh</span>
                                        Reset
                                    </button>
                                </div>
                                
                                <!-- Results count -->
                                <div id="places-search-results-count" class="text-sm text-gray-600 mb-2 hidden"></div>
                                
                                <!-- Results container -->
                                <div id="places-search-results" class="space-y-3 overflow-y-visible">
                                    <p class="text-gray-500 text-center">Search for a restaurant to see results.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Add the modal to the body
            const modalWrapper = document.createElement('div');
            modalWrapper.innerHTML = modalHTML;
            document.body.appendChild(modalWrapper.firstElementChild);
            
            // Add event listener for the collapsible filter section
            setTimeout(() => {
                const toggleFiltersBtn = document.getElementById('toggle-filters-btn');
                if (toggleFiltersBtn) {
                    toggleFiltersBtn.addEventListener('click', () => {
                        const filtersContent = document.querySelector('.collapse-on-mobile');
                        if (filtersContent) {
                            filtersContent.classList.toggle('hidden');
                            
                            // Toggle the icon
                            const icon = toggleFiltersBtn.querySelector('.material-icons');
                            if (icon) {
                                icon.textContent = filtersContent.classList.contains('hidden') ? 
                                    'expand_more' : 'expand_less';
                            }
                        }
                    });
                }
            }, 100);
            
            this.debugLog('Places search modal created');
        }
    }
    
    /**
     * Create a menu button that triggers the modal
     */
    createMenuButtonIfNeeded() {
        // Skip button creation if it already exists
        if (document.getElementById('open-places-search')) {
            this.debugLog('Places search button already exists');
            return;
        }
        
        // Look for the appropriate container
        let container = document.getElementById('michelin-search-section');
        
        // If we find the Michelin section, add our button after it
        if (container) {
            // Create a wrapper section similar to the Michelin one
            const sectionHTML = `
                <div id="places-button-section" class="border-left-4 border-blue-600 transition-all mb-4">
                    <button id="open-places-search" class="flex items-center px-4 py-2 bg-blue-600 text-white rounded shadow hover:bg-blue-700 transition-transform">
                        <span class="material-icons mr-2">place</span>
                        Google Places Search
                    </button>
                </div>
            `;
            
            // Insert after Michelin section
            container.insertAdjacentHTML('afterend', sectionHTML);
            this.debugLog('Places search button added after Michelin section');
        } else {
            // Look for alternate containers like quick actions area
            container = document.querySelector('.quick-actions') || 
                       document.querySelector('.action-buttons') || 
                       document.querySelector('.sidebar');
            
            if (container) {
                // Create a button that fits with the container's style
                const buttonHTML = `
                    <button id="open-places-search" class="flex items-center px-3 py-1 bg-blue-600 text-white rounded shadow hover:bg-blue-700">
                        <span class="material-icons mr-1">place</span>
                        Places Search
                    </button>
                `;
                
                container.insertAdjacentHTML('beforeend', buttonHTML);
                this.debugLog('Places search button added to alternative container');
            }
        }
    }
    
    /**
     * Set up event listeners for the modal and search functionality
     */
    setupEventListeners() {
        this.debugLog('Setting up event listeners');
        
        // Open modal button
        const openPlacesSearchBtn = document.getElementById('open-places-search');
        if (openPlacesSearchBtn) {
            openPlacesSearchBtn.addEventListener('click', () => {
                this.openModal();
            });
        }
        
        // Close modal button
        const closeBtn = document.getElementById('close-places-search-modal');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => this.closeModal());
        }

        // Close when clicking outside modal content
        const modal = document.getElementById('places-search-modal');
        if (modal) {
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    this.closeModal();
                }
            });
        }
        
        // API key save button
        const modalSaveApiKeyBtn = document.getElementById('modal-save-places-api-key');
        if (modalSaveApiKeyBtn) {
            modalSaveApiKeyBtn.addEventListener('click', () => this.saveApiKey('modal-places-api-key'));
        }
        
        // Search button
        const searchBtn = document.getElementById('places-search-btn');
        if (searchBtn) {
            searchBtn.addEventListener('click', () => this.searchPlaces());
        }
        
        // Reset button
        const resetBtn = document.getElementById('places-reset-btn');
        if (resetBtn) {
            resetBtn.addEventListener('click', () => this.resetSearch());
        }
        
        this.debugLog('Event listeners set up');
    }
    
    /**
     * Open the search modal
     */
    openModal() {
        const modal = document.getElementById('places-search-modal');
        if (modal) {
            modal.classList.remove('hidden');
            
            // Initialize Places API in the modal if needed
            if (this.apiKey) {
                const apiKeySection = document.getElementById('modal-places-api-key-section');
                const searchContainer = document.getElementById('modal-places-search-container');
                
                if (apiKeySection) apiKeySection.classList.add('hidden');
                if (searchContainer) searchContainer.classList.remove('hidden');
                
                // Initialize Places API and autocomplete if not already done
                if (!this.apiLoaded) {
                    this.initializePlacesApi();
                } else if (!this.modalAutocompleteWidget) {
                    this.initializeModalPlacesAutocomplete();
                }
            }
            
            this.debugLog('Places search modal opened');
        }
    }
    
    /**
     * Close the search modal
     */
    closeModal() {
        const modal = document.getElementById('places-search-modal');
        if (modal) {
            modal.classList.add('hidden');
            this.debugLog('Places search modal closed');
        }
    }
    
    /**
     * Load Google Places API key from localStorage and database
     */
    async loadApiKey() {
        this.debugLog('Loading Google Places API key');
        
        try {
            // Try to get API key from localStorage first for faster access
            this.apiKey = localStorage.getItem('google_places_api_key') || '';
            
            // If not in localStorage, try to get from database
            if (!this.apiKey && window.dataStorage) {
                try {
                    const setting = await window.dataStorage.getSetting('google_places_api_key');
                    if (setting) {
                        this.apiKey = setting;
                        // Also save to localStorage for faster access next time
                        localStorage.setItem('google_places_api_key', this.apiKey);
                    }
                } catch (dbError) {
                    this.debugLog('Error loading API key from database:', dbError);
                }
            }
            
            // Update UI if we have an API key
            if (this.apiKey) {
                this.debugLog('API key loaded successfully');
                
                // Hide API key section and show search container in modal
                const apiKeySection = document.getElementById('modal-places-api-key-section');
                const searchContainer = document.getElementById('modal-places-search-container');
                
                if (apiKeySection) apiKeySection.classList.add('hidden');
                if (searchContainer) searchContainer.classList.remove('hidden');
                
                // Only initialize Places API if we have a key
                if (!this.apiLoaded) {
                    this.initializePlacesApi();
                }
            } else {
                this.debugLog('No API key found');
            }
        } catch (error) {
            console.error('Error loading API key:', error);
        }
    }
    
    /**
     * Save Google Places API key to localStorage and database
     * @param {string} inputId - The ID of the input element containing the API key
     */
    async saveApiKey(inputId) {
        this.debugLog('Saving Google Places API key');
        
        try {
            const apiKeyInput = document.getElementById(inputId);
            if (!apiKeyInput) {
                throw new Error('API key input not found');
            }
            
            const apiKey = apiKeyInput.value.trim();
            if (!apiKey) {
                this.showNotification('Please enter an API key', 'error');
                return;
            }
            
            // Save to localStorage
            localStorage.setItem('google_places_api_key', apiKey);
            this.apiKey = apiKey;
            
            // Save to database if available
            if (window.dataStorage) {
                try {
                    await window.dataStorage.updateSetting('google_places_api_key', apiKey);
                } catch (dbError) {
                    console.warn('Error saving API key to database:', dbError);
                }
            }
            
            // Show success notification
            this.showNotification('API key saved successfully');
            
            // Hide API key section and show search container in modal
            const apiKeySection = document.getElementById('modal-places-api-key-section');
            const searchContainer = document.getElementById('modal-places-search-container');
            
            if (apiKeySection) apiKeySection.classList.add('hidden');
            if (searchContainer) searchContainer.classList.remove('hidden');
            
            // Initialize Places API
            if (!this.apiLoaded) {
                this.initializePlacesApi();
            }
        } catch (error) {
            console.error('Error saving API key:', error);
            this.showNotification('Error saving API key: ' + error.message, 'error');
        }
    }
    
    /**
     * Initialize the Google Places API
     */
    initializePlacesApi() {
        if (this.apiLoaded) {
            this.debugLog('Places API already initialized');
            return;
        }
        
        if (!this.apiKey) {
            this.debugLog('Cannot initialize Places API: No API key');
            return;
        }
        
        try {
            this.debugLog('Loading Google Places API script');
            
            // Create script element
            const script = document.createElement('script');
            script.src = `https://maps.googleapis.com/maps/api/js?key=${this.apiKey}&libraries=places&callback=initPlacesCallback`;
            script.async = true;
            script.defer = true;
            
            // Define global callback function
            window.initPlacesCallback = () => {
                this.apiLoaded = true;
                this.debugLog('Google Places API loaded successfully');
                
                // Initialize modal autocomplete
                this.initializeModalPlacesAutocomplete();
                
                // Inject CSS to fix dropdown positioning issues
                this.injectDropdownFixStyles();
                
                // Set up observer to fix dropdown positioning
                this.setupAutocompleteObserver();
            };
            
            // Add error handler
            script.onerror = () => {
                console.error('Error loading Google Places API');
                this.showNotification('Error loading Google Places API', 'error');
            };
            
            // Append script to document
            document.head.appendChild(script);
            
        } catch (error) {
            console.error('Error initializing Places API:', error);
            this.showNotification('Error initializing Places API: ' + error.message, 'error');
        }
    }
    
    /**
     * Initialize the Places Autocomplete widget for the modal search
     */
    initializeModalPlacesAutocomplete() {
        try {
            this.debugLog('Creating modal Places Autocomplete widget');
            
            const modalAutocompleteContainer = document.getElementById('modal-places-autocomplete-container');
            if (!modalAutocompleteContainer) {
                this.debugLog('Modal autocomplete container not found');
                return;
            }
            
            // Clear existing content
            modalAutocompleteContainer.innerHTML = '';
            
            // Check if the modern component API is available
            if (window.google && window.google.maps && window.google.maps.places && window.google.maps.places.PlaceAutocompleteElement) {
                this.debugLog('Using PlaceAutocompleteElement API for modal');
                
                // Create the new component
                const autocompleteElement = document.createElement('gmp-place-autocomplete');
                autocompleteElement.setAttribute('placeholder', 'Search for restaurants');
                autocompleteElement.id = 'modal-places-input';
                
                if (this.filterFoodPlacesOnly) {
                    autocompleteElement.restrictType = 'restaurant,cafe,bar,food';
                }
                
                modalAutocompleteContainer.appendChild(autocompleteElement);
                
                // Listen for place selection
                autocompleteElement.addEventListener('gmp-placeselect', (e) => {
                    this.searchPlaceDetails(e.detail.place);
                });
                
            } else {
                this.debugLog('Using classic Autocomplete API for modal');
                
                // Create input element
                const input = document.createElement('input');
                input.id = 'modal-places-input';
                input.className = 'border rounded p-2 w-full';
                input.placeholder = 'Search for restaurants';
                modalAutocompleteContainer.appendChild(input);
                
                // Create autocomplete
                const options = {};
                
                if (this.filterFoodPlacesOnly) {
                    options.types = ['restaurant', 'cafe', 'bar', 'food'];
                }
                
                // Initialize the Places service if not already done
                if (!this.placesService && window.google && window.google.maps) {
                    const mapDiv = document.createElement('div');
                    const map = new google.maps.Map(mapDiv);
                    this.placesService = new google.maps.places.PlacesService(map);
                }
                
                this.modalAutocompleteWidget = new google.maps.places.Autocomplete(input, options);
                
                // Set up place_changed event
                this.modalAutocompleteWidget.addListener('place_changed', () => {
                    const place = this.modalAutocompleteWidget.getPlace();
                    this.searchPlaceDetails(place);
                });
            }
            
            this.debugLog('Modal Places Autocomplete widget created');
            
        } catch (error) {
            console.error('Error creating modal Places Autocomplete widget:', error);
            this.showNotification('Error setting up modal search functionality', 'error');
        }
    }
    
    /**
     * Search for a place and display details
     * @param {Object} place - The place object or prediction
     */
    async searchPlaceDetails(place) {
        try {
            this.showLoading('Searching for restaurant details...');
            
            // Check if we have a full place object with place_id
            if (!place || !place.place_id) {
                throw new Error('Invalid place data');
            }
            
            // Initialize Places service if not already done
            if (!this.placesService && window.google && window.google.maps) {
                const mapDiv = document.createElement('div');
                const map = new google.maps.Map(mapDiv);
                this.placesService = new google.maps.places.PlacesService(map);
            }
            
            // If we just have a place_id, we need to get the full details
            if (place.place_id && (!place.geometry || !place.photos)) {
                await this.getPlaceDetails(place.place_id);
                return; // getPlaceDetails will handle the rest
            }
            
            // We have a full place object, use it directly
            this.processPlaceResults([place]);
            
        } catch (error) {
            this.hideLoading();
            console.error('Error searching for place:', error);
            this.showNotification('Error searching for restaurants: ' + error.message, 'error');
        }
    }
    
    /**
     * Get details for a place by place_id
     * @param {string} placeId - The Google Places place_id
     */
    async getPlaceDetails(placeId) {
        if (!this.placesService) {
            throw new Error('Places service not initialized');
        }
        
        return new Promise((resolve, reject) => {
            this.placesService.getDetails(
                {
                    placeId: placeId,
                    fields: [
                        'name', 'place_id', 'formatted_address', 'geometry', 
                        'types', 'website', 'price_level', 'rating', 
                        'formatted_phone_number', 'photos', 'reviews',
                        'opening_hours', 'vicinity', 'user_ratings_total'
                    ]
                },
                (place, status) => {
                    if (status === google.maps.places.PlacesServiceStatus.OK && place) {
                        this.processPlaceResults([place]);
                        resolve(place);
                    } else {
                        const errorMessage = `Error getting place details: ${status}`;
                        this.showNotification(errorMessage, 'error');
                        reject(new Error(errorMessage));
                    }
                }
            );
        });
    }
    
    /**
     * Process the search results
     * @param {Array} results - Array of place objects
     */
    processPlaceResults(results) {
        try {
            // Store results
            this.searchResults = results;
            
            // Render results
            this.renderResults(results);
            
            // Update results count
            const countDiv = document.getElementById('places-search-results-count');
            if (countDiv) {
                countDiv.classList.remove('hidden');
                countDiv.textContent = `Found ${results.length} result${results.length === 1 ? '' : 's'}`;
            }
            
            this.hideLoading();
            
        } catch (error) {
            this.hideLoading();
            console.error('Error processing search results:', error);
            this.showNotification('Error processing search results', 'error');
        }
    }
    
    /**
     * Perform a places search based on current inputs
     */
    async searchPlaces() {
        const locationCheckbox = document.getElementById('search-places-location');
        
        if (locationCheckbox && locationCheckbox.checked) {
            // If location checkbox is checked, do a nearby search
            await this.searchNearbyPlaces();
        } else {
            // Otherwise, we need input from the autocomplete
            const input = document.getElementById('modal-places-input');
            
            if (!input) {
                this.showNotification('Search input field not found', 'error');
                return;
            }
            
            const inputValue = input.value ? input.value.trim() : '';
            
            if (!inputValue) {
                this.showNotification('Please enter a search term', 'error');
                return;
            }
            
            // If autocomplete widget exists and has a selected place, use it
            if (this.modalAutocompleteWidget) {
                const place = this.modalAutocompleteWidget.getPlace();
                if (place && place.place_id) {
                    await this.searchPlaceDetails(place);
                } else {
                    this.showNotification('Please select a place from the dropdown', 'error');
                }
            } else {
                this.showNotification('Search functionality not fully initialized', 'error');
            }
        }
    }
    
    /**
     * Search for places near the user's current location
     */
    async searchNearbyPlaces() {
        try {
            // Check if we have location data
            if (!this.currentLatitude || !this.currentLongitude) {
                this.showNotification('Location data not available. Please enable location and try again.', 'error');
                return;
            }
            
            this.showLoading('Searching for nearby restaurants...');
            
            // Get selected radius
            const radiusSelect = document.getElementById('search-places-radius');
            const radius = radiusSelect ? parseInt(radiusSelect.value, 10) * 1000 : 5000; // Convert km to meters
            
            // Initialize Places service if not already done
            if (!this.placesService && window.google && window.google.maps) {
                const mapDiv = document.createElement('div');
                const map = new google.maps.Map(mapDiv);
                this.placesService = new google.maps.places.PlacesService(map);
            }
            
            if (!this.placesService) {
                throw new Error('Places service not initialized');
            }
            
            // Create search request
            const request = {
                location: new google.maps.LatLng(this.currentLatitude, this.currentLongitude),
                radius: radius,
                type: this.filterFoodPlacesOnly ? ['restaurant'] : ['establishment']
            };
            
            // Perform search
            const results = await new Promise((resolve, reject) => {
                this.placesService.nearbySearch(request, (results, status) => {
                    if (status === google.maps.places.PlacesServiceStatus.OK) {
                        resolve(results);
                    } else {
                        reject(new Error(`Nearby search failed: ${status}`));
                    }
                });
            });
            
            this.processPlaceResults(results);
            
        } catch (error) {
            this.hideLoading();
            console.error('Error searching nearby places:', error);
            this.showNotification('Error searching for nearby places: ' + error.message, 'error');
        }
    }

    /**
     * Reset the search form and results
     */
    resetSearch() {
        const resultsDiv = document.getElementById('places-search-results');
        if (resultsDiv) {
            resultsDiv.innerHTML = '<p class="text-gray-500 text-center">Search for a restaurant to see results.</p>';
        }
        
        // Clear location data
        this.currentLatitude = null;
        this.currentLongitude = null;
        
        // Reset location checkbox
        const locationCheckbox = document.getElementById('search-places-location');
        if (locationCheckbox) {
            locationCheckbox.checked = false;
        }
        
        // Clear input field
        const input = document.getElementById('modal-places-input');
        if (input) {
            input.value = '';
        }
        
        // Reset search results
        this.searchResults = [];
        
        // Hide results count
        const countDiv = document.getElementById('places-search-results-count');
        if (countDiv) {
            countDiv.classList.add('hidden');
        }
        
        this.debugLog('Search reset');
    }
    
    /**
     * Show a notification message
     * @param {string} message - Message to display
     * @param {string} type - Notification type (success, error, warning, info)
     */
    showNotification(message, type = 'success') {
        if (window.uiUtils && typeof window.uiUtils.showNotification === 'function') {
            window.uiUtils.showNotification(message, type);
            return;
        }
        
        // Use uiManager as fallback
        if (window.uiManager && typeof window.uiManager.showNotification === 'function') {
            window.uiManager.showNotification(message, type);
            return;
        }
        
        // Simple console fallback
        console.log(`[${type.toUpperCase()}] ${message}`);
        
        // For errors, show alert as last resort
        if (type === 'error') {
            alert(`Error: ${message}`);
        }
    }
    
    /**
     * Show loading state
     * @param {string} message - Loading message
     */
    showLoading(message = 'Loading...') {
        this.isLoading = true;
        if (window.uiUtils && typeof window.uiUtils.showLoading === 'function') {
            window.uiUtils.showLoading(message);
            return;
        }
        
        // Use uiManager as fallback
        if (window.uiManager && typeof window.uiManager.showLoading === 'function') {
            window.uiManager.showLoading(message);
            return;
        }
        
        // Simple console fallback
        console.log(`[LOADING] ${message}`);
    }
    
    /**
     * Hide loading state
     */
    hideLoading() {
        this.isLoading = false;
        if (window.uiUtils && typeof window.uiUtils.hideLoading === 'function') {
            window.uiUtils.hideLoading();
            return;
        }
        
        // Use uiManager as fallback
        if (window.uiManager && typeof window.uiManager.hideLoading === 'function') {
            window.uiManager.hideLoading();
            return;
        }
        
        // Simple console fallback
        console.log('[LOADING] Done');
    }
    
    /**
     * Inject CSS that fixes dropdown positioning issues
     */
    injectDropdownFixStyles() {
        // Check if we've already injected the styles
        if (document.getElementById('pac-dropdown-fix-styles')) {
            this.debugLog('Dropdown fix styles already injected');
            return;
        }
        
        const styleEl = document.createElement('style');
        styleEl.id = 'pac-dropdown-fix-styles';
        styleEl.innerHTML = `
            /* Fix Google Places Autocomplete dropdown positioning */
            .pac-container, 
            gmp-pac-container {
                z-index: 9999999 !important;
                position: fixed !important;
                transform: none !important;
                top: auto !important;
                left: auto !important;
                width: auto !important;
                min-width: 300px !important;
                max-width: 95vw !important;
                max-height: 300px !important;
                overflow-y: auto !important;
                overflow-x: hidden !important;
                background-color: white !important;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2) !important;
                border-radius: 0 0 4px 4px !important;
                clip: auto !important;
                clip-path: none !important;
            }
        `;
        
        document.head.appendChild(styleEl);
        this.debugLog('Injected dropdown fix styles');
    }
    
    /**
     * Setup a MutationObserver to fix any autocomplete dropdown that appears
     */
    setupAutocompleteObserver() {
        try {
            // Create an observer to position the dropdown correctly
            const observer = new MutationObserver((mutations) => {
                for (const mutation of mutations) {
                    if (mutation.addedNodes) {
                        for (const node of mutation.addedNodes) {
                            if (node.classList && 
                                (node.classList.contains('pac-container') || 
                                 node.tagName === 'GMP-PAC-CONTAINER')) {
                                
                                this.positionAutocompleteDropdown(node);
                            }
                        }
                    }
                }
            });
            
            // Start observing the document body
            observer.observe(document.body, { childList: true });
            this.dropdownObserver = observer;
            this.debugLog('Autocomplete observer setup');
            
        } catch (error) {
            console.warn('Error setting up autocomplete observer:', error);
        }
    }

    /**
     * Position the autocomplete dropdown correctly
     * @param {HTMLElement} dropdown - The dropdown element to position
     */
    positionAutocompleteDropdown(dropdown) {
        try {
            // Determine the current active input for the dropdown
            let activeInput = document.getElementById('modal-places-input') ||
                              document.querySelector('input:focus') ||
                              document.querySelector('gmp-place-autocomplete');
            
            if (!activeInput) return;
            
            // For shadow DOM components, get the actual input part
            if (activeInput.tagName === 'GMP-PLACE-AUTOCOMPLETE') {
                if (activeInput.shadowRoot) {
                    const shadowInput = activeInput.shadowRoot.querySelector('input');
                    if (shadowInput) {
                        activeInput = shadowInput;
                    }
                }
            }
            
            // Get positions
            const inputRect = activeInput.getBoundingClientRect();
            
            // Position the dropdown
            dropdown.style.top = `${inputRect.bottom + window.scrollY}px`;
            dropdown.style.left = `${inputRect.left + window.scrollX}px`;
            dropdown.style.width = `${inputRect.width}px`;
        } catch (error) {
            console.warn('Error positioning autocomplete dropdown:', error);
        }
    }
    
    /**
     * Clean up resources when the module is no longer needed
     */
    cleanup() {
        // Remove any global event listeners
        if (this.dropdownObserver) {
            this.dropdownObserver.disconnect();
            this.dropdownObserver = null;
        }
        
        // Clear any timers or intervals
        if (this.repositionTimer) {
            clearInterval(this.repositionTimer);
            this.repositionTimer = null;
        }
        
        this.debugLog('Places module cleanup complete');
    }
});

// Prevent duplicate registration
if (!window.placesModule) {
    // Create the module instance
    window.placesModule = new PlacesModule();
}

// If main.js has a registerModule function in its ModuleInitialization object, register there too
if (window.ModuleInitialization && typeof window.ModuleInitialization.registerModule === 'function') {
    window.ModuleInitialization.registerModule('placesModule', PlacesModule);
}

    };
    
    // Initialize the module when the document is ready
    document.addEventListener('DOMContentLoaded', () => {
        // Create instance after a short delay to ensure other modules are loaded
        setTimeout(() => {
            if (!window.placesModule) {
                window.placesModule = new window.PlacesModule();
                console.log('Google Places Module initialized globally');
            }
        }, 1000);
    });
} else {
    console.log('PlacesModule already defined, skipping redefinition');
}
